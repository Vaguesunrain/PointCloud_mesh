#include <pcl/point_types.h>
#include <pcl/io/pcd_io.h>
#include <pcl/io/vtk_io.h>
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl/features/normal_3d.h>
#include <pcl/surface/gp3.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <boost/thread/thread.hpp>
#include <fstream>
#include <iostream>
#include <stdio.h>
#include <string.h>

int main(int argc, char** argv)
{

    /*点云载入模块*/
    // 点云模型读入,此处读入为PCD格式点云文件.数据类型为PointXYZ.
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
    if (pcl::io::loadPCDFile<pcl::PointXYZ>("rabbit.pcd", *cloud) == -1)
    {
        PCL_ERROR("Couldn't read file mypointcloud.pcd\n");  //若读取失败将提示
        return -1;
    }
    std::cerr << "点云读入   完成" << std::endl;


    /*法向估计模块*/
    // Normal estimation（法向量估计）
    pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> n;//创建法向估计对象
    pcl::PointCloud<pcl::Normal>::Ptr normals(new pcl::PointCloud<pcl::Normal>);//创建法向数据指针
    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);//创建kdtree用于法向计算时近邻搜索
    tree->setInputCloud(cloud);//为kdtree输入点云
    n.setInputCloud(cloud);//为法向估计对象输入点云
    n.setSearchMethod(tree);//设置法向估计时采用的搜索方式为kdtree
    n.setKSearch(20);//设置法向估计时,k近邻搜索的点数
    n.compute(*normals);  //进行法向估计

    std::cerr << "法线计算   完成" << std::endl;

    /*点云数据与法向数据拼接*/
    // 创建同时包含点和法向的数据结构的指针
    pcl::PointCloud<pcl::PointNormal>::Ptr cloud_with_normals(new pcl::PointCloud<pcl::PointNormal>);
    //将已获得的点数据和法向数据拼接
    pcl::concatenateFields(*cloud, *normals, *cloud_with_normals);


    // 创建另一个kdtree用于重建
    pcl::search::KdTree<pcl::PointNormal>::Ptr tree2(new pcl::search::KdTree<pcl::PointNormal>);
    //为kdtree输入点云数据,该点云数据类型为点和法向
    tree2->setInputCloud(cloud_with_normals);

    /*曲面重建模块*/
    // 创建贪婪三角形投影重建对象
    pcl::GreedyProjectionTriangulation<pcl::PointNormal> gp3;
    //创建多边形网格对象,用来存储重建结果
    pcl::PolygonMesh triangles;

    //设置参数
    gp3.setSearchRadius(25);  // 设置连接点之间的最大距离（最大边长）用于确定k近邻的球半径（默认为0）
    gp3.setMu(2.5);  // 设置最近邻距离的乘子，已得到每个点的最终搜索半径（默认为0）
    gp3.setMaximumNearestNeighbors(100);  //设置搜索的最近邻点的最大数量
    gp3.setMaximumSurfaceAngle(M_PI / 2); // 45 degrees 最大平面角
    gp3.setMinimumAngle(M_PI / 18); // 10 degrees 每个三角的最大角度
    gp3.setMaximumAngle(2 * M_PI / 3); // 120 degrees
    gp3.setNormalConsistency(false);  //若法向量一致，设为true
    // 设置点云数据和搜索方式
    gp3.setInputCloud(cloud_with_normals);
    gp3.setSearchMethod(tree2);
    //开始重建
    gp3.reconstruct(triangles);
    std::cerr << "重建   完成" << std::endl;

    //将重建结果保存到硬盘文件中,重建结果以VTK格式存储
    pcl::io::saveVTKFile("mymesh.vtk", triangles);

    // Additional vertex information
    std::vector<int> parts = gp3.getPartIDs();
    std::vector<int> states = gp3.getPointStates();
    fstream fs;
    fs.open("partsID.txt", ios::out);
    if (!fs)
    {
        return -2;
    }
    fs << "点云数量为：" << parts.size() << "\n";
    for (int i = 0; i < parts.size(); i++)
    {
        if (parts[i] != 0)
        {
            fs << parts[i] << "\n";   //这的fs对吗？
        }
    }
    

    //图形显示模块
    //创建显示对象指针
    std::cerr << "开始显示 ........" << std::endl;
    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer(new pcl::visualization::PCLVisualizer("3D Viewer"));
    viewer->setBackgroundColor(0, 0, 0.6);  //设置窗口颜色
    viewer->addPolygonMesh(triangles, "my");  //设置所要显示的网格对象
    //设置网格模型显示模式
    //viewer->setRepresentationToSurfaceForAllActors(); //网格模型以面片形式显示  
    //viewer->setRepresentationToPointsForAllActors(); //网格模型以点形式显示  
    viewer->setRepresentationToWireframeForAllActors();  //网格模型以线框图模式显示
    viewer->addCoordinateSystem(0.1);  //设置坐标系,参数为坐标显示尺寸
    viewer->initCameraParameters();
    while (!viewer->wasStopped())
    {
        viewer->spinOnce(100);
        boost::this_thread::sleep(boost::posix_time::microseconds(100000));
    }


    // Finish
    return 0;
}

